#include <iostream>
#include <string>
#include <windows.h>
#include <fstream>

using namespace std;
//прототипы 
string razn(string sa, string sb); // вычитание длинных чисел
bool comparison(string x, string y); //сравнение длинных чисел "<="
string mult(string sx, int m); //умножение длинного числа на цифру

int main()
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);
    int size_a, size_b, i = 0, j, num; //size_a - длина заданного числа, size_b - длинна результата, i,j - счетчики, num - подобранная цифра
    string a, c, x, t, k, d;//a - заданное число, c - результативное число, x,t,k,d - промежуточные переменные 
    bool check, check_empty;
    ifstream f1("input1.txt");
    getline(f1, a); // чтение строки из файла
    ofstream f2("output.txt", ios::out);
    size_a = a.size();
    check = check_empty = false;
    if (size_a > 0 and !(a == "0")) //удаление незначащих нулей  
    {
        while (a[i] == '0')
        {
            a.erase(i, 1);
            size_a--;
        }
    }
    if (size_a == 0) //проверка на "пустой фаил"
    {
        check = true;
        check_empty = true;
    }
    for (i = 0; i < size_a; i++) //проверка на правильность введённых данных
    {
        if (a[i] < '0' or a[i] > '9')
        {
            check = true;
        }
    }
    if (!(check))
    {
        size_b = (size_a + 1) / 2; //длина результата после удаления незначащих (при их существовании) 
        int* b = new int[size_b];
        for (i = 0; i < size_b; i++) //заполняем нулями массив, где будет храниться ответ
        {
            b[i] = 0;
        }
        if (size_a % 2 != 0) //заполняем массив парами цифр числа, если 1-я цифра без пары
        {
            b[0] = a[0] - '0';
            j = 1;
            for (i = 1; i < size_b; i++)
            {
                b[i] = (a[j] - '0') * 10 + (a[j + 1] - '0');
                j += 2;
            }
        }
        else //заполняем массив парами цифр числа, если количество цифр четное 
        {
            j = 0;
            for (i = 0; i < size_b; i++)
            {
                b[i] = (a[j] - '0') * 10 + (a[j + 1] - '0');
                j += 2;
            }
        }

        for (i = 0; i <= 9; i++) // находим из 1-ой пары первую цифру результата 
        {
            if (i * i <= b[0])
            {
                num = i;
            }
            else
            {
                break;
            }
        }
        if (size_b > 1) b[1] = (b[0] - num * num) * 100 + b[1]; //остаток переносим к 2-ой паре
        b[0] = num; // записываем 1-ую цифру результата
        c = ""; k = ""; t = "";
        c = to_string(b[0]); //c - 1-я цифра
        k = to_string(b[1]); //k - 2-я пара
        for (i = 1; i < size_b; i++)
        {
            x = mult(c, 2); // удваиваем результат, полученный на прошлом шаге, x - количество десятков
            int l = 0, r = 9, m;
            while (l <= r) // с помощью бин.поиска подбираем нужную цифру
            {
                m = (l + r) / 2; // подбираемая цифра 
                t = x + to_string(m); // составляем число t, где x - десятки, m - единицы 
                if (comparison(mult(t, m), k) == 1) // подбираемся цифра пойдет в результат, если t*m <= k, проверяем это условие
                {
                    num = m;
                    l = m + 1;
                }
                else
                {
                    r = m - 1;
                }
            }
            if (i != size_b - 1) // если не конец 
            {
                d = "";
                if (b[i + 1] < 10) //когда пары формировались, пары вида "00" -> "0", "01" -> "1", поэтому к d добавляем "0" 
                {
                    d = razn(k, mult(x + to_string(num), num)) + "0" + to_string(b[i + 1]); //остаток переносим в следующую пару
                    for (j = 0; j < d.size() - 1; j++) //удаляем незначащие нули, чтобы не возникло проблем с произведением 
                    {
                        if (d[j] == '0')
                        {
                            d.erase(j, 1);
                        }
                        else
                        {
                            break;
                        }
                    }
                    k = "";
                    k = d; //в следующую пару записываем остаток от разности + пара
                }
                else
                {
                    d = razn(k, mult(x + to_string(num), num)) + to_string(b[i + 1]); // остаток переносим в следующую пару
                    for (j = 0; j < d.size() - 1; j++) //удаляем незначащие нули, чтобы не возникло проблем с произведением 
                    {
                        if (d[j] == '0')
                        {
                            d.erase(j, 1);
                        }
                        else
                        {
                            break;
                        }
                    }
                    k = "";
                    k = d; // в следующую пару записываем остаток от разности + пара
                }
            }
            b[i] = num; //записываем уже подобранную цифру 
            c += to_string(b[i]); //в результирующую строку записываем подобранную цифру
        }
        f2 << c;//записываем результат в файл
        f1.close();
        f2.close();
        delete[]b;
    }
    else
    {
        if (check_empty)
            f2 << "Файл пуст."; //если файл пуст, то выводится сообщение
        else
            f2 << "Введенные данные имели неверный формат."; //если введённые данные неверны, то выводится сообщение
    }
    return 0;
}
string mult(string sx, int m) //умножение длинного числа на цифру 
{
    int length = sx.size() + 1, z = 0; //length - длина результата с местом для переноса, z - разряд для переноса 
    int* x = new int[length];
    for (int i = 0; i < length; i++) //заполняем нулями массив, где будет храниться ответ
    {
        x[i] = 0;
    }
    for (int i = sx.size() - 1; i >= 0; i--) //заполняем массив цифрами числа с конца
    {
        x[sx.size() - 1 - i] = sx[i] - '0';
    }
    for (int i = 0; i < length; i++) //вычисления
    {
        if (i < sx.size())
        {
            x[i] = x[i] * m + z; //умножается последний разряд числа на цифру и прибавляется разряд для переноса с прошлого шага
            z = x[i] / 10; //записывается разряд для переноса 
            x[i] %= 10; //если есть разряд для переноса, он отсекается
        }
    }
    x[length - 1] = z; //на последнее место записывается разряд для переноса 
    for (int i = 0; length > 1; i--)
    {
        if (x[length - 1] == 0) //удаляются незначащие нули
        {
            length--;
        }
        else
        {
            break;
        }
    }
    sx = ""; //результирующая строка
    for (int i = length - 1; i >= 0; i--)
    {
        sx += to_string(x[i]); //добавляем по 1 цифре к результату с конца
    }
    return sx;
}
bool comparison(string x, string y) //сравнение длинных чисел "<="
{
    bool t = true; //true - если 1-е <= 2-ого, false - если 1-е > 2-го
    if (x.size() < y.size()) //если длина 1-го меньше длины 2-го, то 1-е число меньше
    {
        t = true;
    }
    if (x.size() > y.size()) //если длина 1-го больше длины 2-го, то 1-е число больше
    {
        t = false;
    }
    if (x.size() == y.size()) //если числа одинаковой длины, то сравниваем по разрядам, начиная с 1
    {
        for (int i = 0; i < x.size(); i++)
        {
            if (x[i] == y[i]) //пока разряды равны, пропускаем 
            {
                continue;
            }
            else
            {
                if (x[i] > y[i]) //если разряд 1-го числа > разряда 2-го, то 1-е числа > 2-го числа
                {
                    t = false;
                    break;
                }
                else //если разряд 1-го числа < разряда 2-го, то 1-е числа < 2-го числа
                {
                    t = true;
                    break;
                }
            }
        }
    }
    return t;
}
string razn(string sa, string sb) // вычитание длинных чисел
{
    int size_a, size_b, length;
    size_a = sa.length(); // длина 1-ого числа
    size_b = sb.length(); // длина 2-ого числа
    string d = "0";
    int k = 2;
    length = size_a; //1-е число >= 2-е числ0, это проверено на предыдущем шаге
    if (size_a > size_b) //k=1, если 1-е числа > 2-го числа
    {
        k = 1;
    }
    else
    {
        for (int i = 0; i < length; i++)
        {
            if (sa[i] > sb[i])
            {
                k = 1;
                break;
            }
        }
    }
    if (k == 2) return d; //k=2, если числа равны, то их разность равна 0
    else
    {
        int* a = new int[size_a];
        int* b = new int[size_b];
        int* c = new int[length];
        for (int i = 0; i < length; i++) //заполняем нулями массив, где будет храниться ответ
        {
            c[i] = 0;
        }
        for (int i = size_a - 1; i >= 0; i--) //заполняем массив цифрами 1-го числа с конца
        {
            a[size_a - 1 - i] = sa[i] - '0';
        }
        for (int i = size_b - 1; i >= 0; i--) //заполняем массив цифрами 2-го числа с конца 
        {
            b[size_b - 1 - i] = sb[i] - '0';
        }
        for (int i = 0; i < length; i++) //вычитание
        {
            if (i < size_b)
            {
                c[i] = a[i] - b[i];
                if (c[i] < 0)
                {
                    c[i] += 10;
                    a[i + 1]--;
                }
            }
            else
                c[i] = a[i];
        }
        sb = "";
        for (int i = 0; length > 0; i--) //удаляем незначащие нули
        {
            if (c[length - 1] == 0)
            {
                length--;
            }
            else
            {
                break;
            }
        }
        for (int i = length - 1; i >= 0; i--)
        {
            sb += to_string(c[i]); //добавляем по 1 цифре к результату с конца
        }
        return sb;
    }
}